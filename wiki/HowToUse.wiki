<wiki:toc max_depth="3" />

=Create the control=
{{{
#include <html\htmlcontrol.h>

iControl = CHtmlControl::NewL(NULL);
iControl->SetRect(ClientRect());
iControl->SetMopParent(this);
iControl->ActivateL();
AddToStackL(iControl );
}}}

CHtmlControl::NewL的唯一参数是父控件的指针。如果将CHtmlControl用于组合组件中，则传入父控件的指针；否则，传入NULL即可。

=Add HTML content=
最简单的方法是使用AppendContentL，它将HTML添加到文档的末端，例如：
{{{
_LIT(KHtml, "<b>Hello world</b>");
iControl->AppendContentL(KHtml);
iControl->RefreshAndDraw();
}}}
你可以不断调用AppendContentL添加新的HTML到控件里，但每次添加的HTML必须是完整的HTML文本，例如以下的代码是错误的：
{{{
//WRONG
_LIT(KHtml1, "<b>Hello world");
iControl->AppendContentL(KHtml1);
_LIT(KHtml2, "</b>");
iControl->AppendContentL(KHtml2);
}}}
第二种方法使用InsertContentL, 它可以指定新加入的HTML的位置，例如：
{{{
_LIT(KHtml1, "<div id='a'>world</div>");
iControl->AppendContentL(KHtml1);
_LIT(KHtml2, "Hello ");
iControl->InsertContentL(iControl->Element(_L("a")), EBeforeBegin, KHtml2);
iControl->RefreshAndDraw();
}}}
第三种方法是使用元素的innerText和innerHTML属性，例如：
{{{
_LIT(KHtml1, "<div id='a'></div>");
iControl->AppendContentL(KHtml1);
_LIT(KHtml2, "<b>Hello world</b>");
iControl->Element(_L("a"))->SetProperty(KHStrInnerHtml, KHtml2);
iControl->RefreshAndDraw();
}}}
无论使用哪种方法，最后都应该调用Refresh方法，以使控件更新内部各个元素的位置和状态。而调用RefreshAndDraw则相当于相继调用Refresh和DrawNow，即
{{{
iControl->Refresh();
iControl->DrawNow();
}}}

=Access Elements=
HtmlControl使用Body元素作为最顶级的容器元素，可以调用Body()获得Body元素指针。例如：
{{{
  CHtmlElement* body = iControl->Body();
}}}

使用以下两个方法可以获取控件中某个元素的指针：
{{{
CHtmlElement* Element(const TDesC& aId, TInt aIndex = 0) const;
CHtmlElement* ElementByTag(const TDesC& aTagName, TInt aIndex = 0) const;
}}}
只要不更改控件的内容，返回的指针一直有效，调用者不需要删除该指针。
注意在HtmlControl中，HTML中的Name属性最终将转化为ID属性；另外，元素的ID并不要求唯一。
例如：
{{{
_LIT(KHtml, "<div id='a'>Hello</div> <div id='a'>world</div>");
iControl->AppendContentL(KHtml);
CHtmlElement* e1 = iControl->Element(_L("a"), 0); //hello
CHtmlElement* e2 = iControl->Element(_L("a"), 1); //world
}}}
也可以通过标签名称得到元素指针，例如：
{{{
_LIT(KHtml, "<div>Hello world </div>");
iControl->AppendContentL(KHtml);
CHtmlElement* e = iControl->ElementByTag(KHStrDiv);
}}}

不是所有HTML的标签都可以通过ID或者标签名称引用，例如：b u i font p hr等。

如果需要枚举控件中的元素，可以使用THtmlElementIter，下面的例子枚举了控件中的img元素：
{{{
#include <html\htmlelementiter.h>
_LIT(KHtml, "<img src='1.gif'><img src='2.gif'><img src='3.gif'>");
iControl->AppendContentL(KHtml);
THtmlElementIter iter(iControl->Body(), KNullDesC, KHStrImg);
while(it.Next())
{
  CHtmlElement* e = it();
}
}}}

如果需要删除控件中的元素，可以使用RemoveElement方法，例如：
{{{
_LIT(KHtml, "<div id='a'>Hello</div> <div id='a'>world</div>");
iControl->AppendContentL(KHtml);
CHtmlElement* e1 = iControl->Element(_L("a"), 0); //hello
iControl->RemoveElement(e1);
}}}
如果需要清除某个元素的内容，可以设置innerHTML为空，例如：
{{{
e1->SetProperty(KHStrInnerHTML, KNullDesC);
}}}
清除控件所有的内容，可以这样：
{{{
iControl->ClearContent();
}}}

=Using styles=
HtmlControl支持CSS，请看下面的例子：
{{{
_LIT(KHtml, "<div style='font-size:large;color:red'>Hello world</div>");
iControl->AppendContentL(KHtml);
iControl->RefreshAndDraw();
}}}
也可以使用样式表，例如:
{{{
_LIT(KStyleSheet, ".noname { font-size:large;color:red }");
iControl->AddStyleSheetL(KStyleSheet);
_LIT(KHtml, "<div class='noname'>Hello world</div>");
iControl->AppendContentL(KHtml);
iControl->RefreshAndDraw();
}}}
可以多次使用AddStyleSheetL添加样式定义。如果要删除样式定义，可以通过指定选择符删除，例如：
{{{
iControl->RemoveStyleClass(_L("noname"));
}}}
也可以使用ClearStyleSheet清除所有自定义的样式，例如:
{{{
iControl->ClearStyleSheet();
}}}

如果需要定义一个整个应用程序中所有HtmlControl都有效的样式表，可以使用HtmlCtlLib::AddGlobalStyleSheetL, 例如：
{{{
_LIT(KStyleSheet, "INPUT { border:2 }"
                  "TEXTAREA { border:2 }"
);
HtmlCtlLib::AddGlobalStyleSheetL(KStyleSheet);
}}}

=Using Layout=
使用CSS属性中的left、top、width、height、margin、padding进行元素的定位。
 * left和top指定元素相对于容器的位置。一般都不推荐使用left和top定位元素，因为绝对定位的方式在各种屏幕大小下效果不相同。
 * 使用width和height控制元素的宽度和高度，单位是像素。也可以使用百分比，例如width:100%，则无论在何种屏幕大小下，都将占满横向的宽度。
 * 使用margin控制元素与相邻元素的距离。
 * 使用padding控制容器中的元素的布局，只有BODY和DIV元素支持。
这几个CSS属性的详细用法可以参考CSS文档。

DIV或BODY将作为其它元素的容器，容器内的元素将继承容器的文字样式，同时使用容器的左上角作为原点。例如：
{{{
_LIT(KHtml, "<div style='width:100%; height:50; border:1 black solid; padding:auto auto; color:red; font-weight:bold'>Hello world</div>");
iControl->AppendContentL(KHtml);
iControl->RefreshAndDraw();
}}}
实际效果如下：

这里padding:auto auto指示容器中的元素左右居中，上下居中。


